{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#rest-framework-yaml","title":"REST Framework YAML","text":"<p>YAML support for Django REST Framework</p>"},{"location":"#overview","title":"Overview","text":"<p>YAML support for the Django REST Framework, forked from https://github.com/jpadilla/django-rest-framework-yaml.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python (3.8, 3.9, 3.10, 3.11)</li> <li>Django (3.2, 4.*)</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install using <code>pip</code>...</p> <pre><code>$ pip install drf-yaml\n</code></pre>"},{"location":"#example","title":"Example","text":"<pre><code>REST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': (\n        'drf_yaml.parsers.YAMLParser',\n    ),\n    'DEFAULT_RENDERER_CLASSES': (\n        'drf_yaml.renderers.YAMLRenderer',\n    ),\n}\n</code></pre> <p>You can also set the renderer and parser used for an individual view, or viewset, using the APIView class based views.</p> <pre><code>from rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom drf_yaml.parsers import YAMLParser\nfrom drf_yaml.renderers import YAMLRenderer\n\nclass ExampleView(APIView):\n    \"\"\"\n    A view that can accept POST requests with YAML content.\n    \"\"\"\n    parser_classes = (YAMLParser,)\n    renderer_classes = (YAMLRenderer,)\n\n    def post(self, request, format=None):\n        return Response({'received data': request.DATA})\n</code></pre>"},{"location":"#sample-output","title":"Sample output","text":"<pre><code>---\n-\n  email: jpadilla@example.com\n  is_staff: true\n  url: \"http://127.0.0.1:8000/users/1/\"\n  username: jpadilla\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<p>Install testing requirements.</p> <pre><code>$ poetry install\n</code></pre> <p>Run with pytest.</p> <pre><code>$ poetry run pytest\n</code></pre> <p>You can also use the excellent tox testing tool to run the tests against all supported versions of Python and Django. Install tox globally, and then simply run:</p> <pre><code>$ tox\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>To build the documentation, you'll need to install <code>mkdocs</code>.</p> <pre><code>$ poetry install --only docs\n</code></pre> <p>To preview the documentation:</p> <pre><code>$ poetry run mkdocs serve\nRunning at: http://127.0.0.1:8000/\n</code></pre> <p>To build the documentation:</p> <pre><code>$ poetry run mkdocs build\n</code></pre>"},{"location":"parsers/","title":"Parsers","text":""},{"location":"parsers/#setting-the-parsers","title":"Setting the parsers","text":"<p>The default set of parsers may be set globally, using the <code>DEFAULT_PARSER_CLASSES</code> setting.  For example, the following settings would allow requests with <code>YAML</code> content.</p> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_PARSER_CLASSES': (\n        'drf_yaml.parsers.YAMLParser',\n    )\n}\n</code></pre> <p>You can also set the parsers used for an individual view, or viewset, using the <code>APIView</code> class based views.</p> <pre><code>from rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom drf_yaml.parsers import YAMLParser\n\nclass ExampleView(APIView):\n    \"\"\"\n    A view that can accept POST requests with YAML content.\n    \"\"\"\n    parser_classes = (YAMLParser,)\n\n    def post(self, request, format=None):\n        return Response({'received data': request.DATA})\n</code></pre> <p>Or, if you're using the <code>@api_view</code> decorator with function based views.</p> <pre><code>@api_view(['POST'])\n@parser_classes((YAMLParser,))\ndef example_view(request, format=None):\n    \"\"\"\n    A view that can accept POST requests with YAML content.\n    \"\"\"\n    return Response({'received data': request.DATA})\n</code></pre>"},{"location":"parsers/#api-reference","title":"API Reference","text":""},{"location":"parsers/#yamlparser","title":"YAMLParser","text":"<p>Parses <code>YAML</code> request content.</p> <p>Requires the <code>pyyaml</code> package to be installed.</p> <p>.media_type: <code>application/yaml</code></p>"},{"location":"renderers/","title":"Renderers","text":""},{"location":"renderers/#setting-the-renderers","title":"Setting the renderers","text":"<p>The default set of renderers may be set globally, using the <code>DEFAULT_RENDERER_CLASSES</code> setting.  For example, the following settings would use <code>YAML</code> as the main media type and also include the self describing API.</p> <pre><code>REST_FRAMEWORK = {\n    'DEFAULT_RENDERER_CLASSES': (\n        'drf_yaml.renderers.YAMLRenderer',\n    )\n}\n</code></pre> <p>You can also set the renderers used for an individual view, or viewset, using the <code>APIView</code> class based views.</p> <pre><code>from django.contrib.auth.models import User\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom drf_yaml.renderers import YAMLRenderer\n\nclass UserCountView(APIView):\n    \"\"\"\n    A view that returns the count of active users in YAML.\n    \"\"\"\n    renderer_classes = (YAMLRenderer,)\n\n    def get(self, request, format=None):\n        user_count = User.objects.filter(active=True).count()\n        content = {'user_count': user_count}\n        return Response(content)\n</code></pre> <p>Or, if you're using the <code>@api_view</code> decorator with function based views.</p> <pre><code>@api_view(['GET'])\n@renderer_classes((YAMLRenderer,))\ndef user_count_view(request, format=None):\n    \"\"\"\n    A view that returns the count of active users in YAML.\n    \"\"\"\n    user_count = User.objects.filter(active=True).count()\n    content = {'user_count': user_count}\n    return Response(content)\n</code></pre>"},{"location":"renderers/#api-reference","title":"API Reference","text":""},{"location":"renderers/#yamlrenderer","title":"YAMLRenderer","text":"<p>Renders the request data into <code>YAML</code>.</p> <p>Requires the <code>pyyaml</code> package to be installed.</p> <p>Note that non-ascii characters will be rendered using <code>\\uXXXX</code> character escape.  For example:</p> <pre><code>unicode black star: \"\\u2605\"\n</code></pre> <p>.media_type: <code>application/yaml</code></p> <p>.format: <code>'.yaml'</code></p> <p>.charset: <code>utf-8</code></p>"}]}